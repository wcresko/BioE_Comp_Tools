---
title: "Week 4 Computational Tools for Bioengineers"
author: "Bill Cresko"
format: 
  revealjs:
    footer: BioE_Comp_Tools_2025 - Knight Campus 
    transition: fade
    transition-speed: slow
editor: visual
---

```{r}
library(tidyverse)
library(gt)
library(readxl)
theme_set(theme_minimal())
```

## Goals for today

-   Finish using GREP for large files
-   Introduction to Scripts in Unix and R
-   Using R Studio and Visual Studio Code (VSC) as script editors

# Working with Large Genomic Data Files

## Human Chromosome Data {.smaller}

-   Genomic data files can be massive (human genome \~6 billion base pairs)
-   FASTA format is standard for sequence data
-   Perfect use case for Unix pipes and redirection
-   Let's work with human genome assembly version 38 (\~3.1 GB)

## Downloading Genomic Data {.smaller}

Download version 38 of the human genome from NCBI:

``` bash

# Using `wget` to download human genome

wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/001/405/\
GCF_000001405.40_GRCh38.p14/GCF_000001405.40_GRCh38.p14_genomic.fna.gz

# Or using `curl` and save with specific name

curl -o human_genome.fa.gz https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/001/405/\
GCF_000001405.40_GRCh38.p14/GCF_000001405.40_GRCh38.p14_genomic.fna.gz
```

-   `wget` and `curl` are both tools for downloading files
-   The backslash (`\`) allows long URLs to span multiple lines
-   `.gz` extension means the file is compressed

# GREP and Regular Expressions

## What is GREP? {.smaller}

-   **GREP** = Global Regular Expression Print
-   Powerful text search tool in Unix
-   Searches for patterns in files or input streams
-   Returns lines that match the pattern
-   Essential for large data processing

Basic syntax:

``` bash
grep [options] pattern [file...]
```

## Basic GREP Usage {.smaller}

``` bash
# Search for a simple pattern
grep "ACGT" sequences.txt

# Case-insensitive search
grep -i "gene" annotations.txt

# Count matching lines
grep -c ">" proteins.fasta

# Show line numbers
grep -n "ERROR" logfile.txt

# Invert match (show non-matching lines)
grep -v "^#" data.txt    # Skip comment lines

# Search multiple files
grep "mutation" *.txt
```

## Introduction to Regular Expressions {.smaller}

Regular expressions (regex) are patterns for matching text:

-   **`.`** = any single character
-   **`*`** = zero or more of preceding character
-   **`+`** = one or more of preceding character
-   **`?`** = zero or one of preceding character
-   **`^`** = start of line
-   **`$`** = end of line
-   **`[abc]`** = any character in set
-   **`[^abc]`** = any character NOT in set
-   **`\`** = escape special characters

## Basic Regex Examples {.smaller}

``` bash
# Match DNA sequences
grep "^ATG" genes.txt         # Lines starting with ATG
grep "TAG$" genes.txt         # Lines ending with TAG
grep "A.G" sequences.txt      # A, any char, then G

# Character classes
grep "[ACGT]" dna.txt         # Any DNA base
grep "[^ACGT]" dna.txt        # Non-DNA characters
grep "[0-9]" data.txt         # Any digit
grep "[A-Za-z]" text.txt      # Any letter

# Quantifiers
grep "A\{3\}" sequence.txt    # Exactly 3 A's
grep "T\{2,4\}" sequence.txt  # 2 to 4 T's
grep "GC*" sequence.txt       # G followed by 0+ C's
```

## Extended Regular Expressions {.smaller}

Use `grep -E` or `egrep` for extended regex:

``` bash
# Alternation (OR)
grep -E "start|stop|pause" commands.txt

# Grouping
grep -E "(ATG|GTG|TTG)" codons.txt

# Plus quantifier (one or more)
grep -E "A+T+G+" sequences.txt

# Question mark (optional)
grep -E "colou?r" british_american.txt

# Complex patterns for bioinformatics
grep -E "^>sp\|[A-Z0-9]+\|" uniprot.fasta  # UniProt headers
grep -E "[ACGT]{20,}" primers.txt          # Sequences 20bp+
```

## Combining GREP with Pipes {.smaller}

``` bash
# Count unique sequence headers
grep "^>" sequences.fasta | sort | uniq | wc -l

# Extract gene names from GFF file
grep -v "^#" annotation.gff | cut -f9 | grep -oE "gene=[^;]+"

# Find sequences without stop codons
grep -v -E "(TAA|TAG|TGA)" orfs.txt

# Quality control pipeline
zcat reads.fastq.gz | grep -A1 "^@" | grep -v "^--" | 
  grep -E "^[ACGTN]+$" | grep -c "N"

# Search and replace with sed (uses regex)
grep "gene" data.txt | sed 's/gene/GENE/g'
```

## Analyzing Sequence Content {.smaller}

Combine Unix tools to analyze genomic data:

``` bash
# Count total bases in chromosome 21

grep -v "^>" human_genome.fa | tr -d '\n' | wc -c

# Count each type of base

grep -v "^>" human_genome.fa | tr -d '\n' | 
  fold -w1 | sort | uniq -c

# Calculate GC content

grep -v "^>" human_genome.fa | tr -d '\n' | 
  tr -cd 'GCgc' | wc -c

# Find simple sequence repeats (e.g., "ATATAT...")

grep -v "^>" human_genome.fa | grep -oE "(AT){5,}"
```

## Working with Compressed Files {.smaller}

Most genomic data is compressed to save space:

``` bash
# View compressed files without extracting

zcat file.gz | head
zless file.gz
zgrep "pattern" file.gz

# Compress and decompress

gzip file.txt          # Creates file.txt.gz
gunzip file.txt.gz     # Restores file.txt
gzip -k file.txt       # Keep original file

# Work directly with compressed files

zcat reads.fastq.gz | grep "^@" | wc -l

# Concatenate compressed files

zcat file1.gz file2.gz | gzip > combined.gz
```

## Examining Large Files Efficiently {.smaller}

Don't use `cat` on huge files! Use these approaches:

``` bash
# Decompress and look at first 10 lines

gunzip -c human_genome.fa.gz | head -10

# Check file size before and after decompression

ls -lh human_genome.fa.gz
gunzip human_genome.fa.gz
ls -lh human_genome.fa

# Count sequences in FASTA file (lines starting with >)

grep "^>" human_genome.fa | wc -l

# View sequence headers only

grep "^>" human_genome.fa | less
```

## Homework - microbial genome analysis {.smaller}

With a sample FASTA file:

1.  Download a bacterial genome from NCBI
2.  Count the number of genes (sequences)
3.  Calculate the total genome size
4.  Find the longest and shortest genes
5.  Calculate overall GC content
6.  Search for specific motifs or restriction sites
7.  Extract protein-coding sequences based on headers

------------------------------------------------------------------------

# Scripting in Unix, R and Python

```{r, echo=FALSE, out.width='75%', fig.align='center'}
knitr::include_graphics("images/RStudio_Screenshot.png")
```

------------------------------------------------------------------------

## What is a Shell Script? {.smaller}

-   Text file containing Unix commands
-   Automates repetitive tasks
-   Makes complex workflows reproducible
-   Essential for bioinformatics pipelines
-   Can include:
    -   Variables and arrays
    -   Conditionals (if/then/else)
    -   Loops (for/while)
    -   Functions
    -   Command-line arguments

## Creating Your First Script {.smaller}

``` bash
#!/bin/bash
# This is a shebang - tells system which interpreter to use

# This is a comment - documents your code
echo "Hello, Bioengineering!"

# Set a variable
NAME="DNA Analysis"
echo "Running $NAME"

# Use command output as variable
DATE=$(date +%Y-%m-%d)
echo "Analysis date: $DATE"

# Simple calculation
COUNT=5
DOUBLE=$((COUNT * 2))
echo "Double of $COUNT is $DOUBLE"
```

Save as `first_script.sh` and run with `bash first_script.sh`

## Making Scripts Executable {.smaller}

``` bash
# Check current permissions
ls -l first_script.sh

# Make executable (add execute permission)
chmod +x first_script.sh

# Now you can run it directly
./first_script.sh
```

Best practice: Always use `chmod +x` for your scripts

## Command-Line Arguments {.smaller}

``` bash
#!/bin/bash
# Script: process_fasta.sh

# $0 is the script name

echo "Script name: $0"

# $# is the number of arguments

echo "Number of arguments: $#"

# Check if enough arguments provided FIRST

if [ $# -lt 2 ]; then
    echo "Usage: $0 input.fasta output.txt"
    exit 1
fi

# Now safe to use the arguments

echo "Processing file: $1"
echo "Output will be: $2"

# $@ is all arguments (should be quoted)

echo "All arguments: $@"
```

Run as: `./process_fasta.sh input.fa results.txt`

## Variables and Arrays {.smaller}

``` bash
#!/bin/bash

# Variables (no spaces around =)
SPECIES="Homo sapiens"
CHROMOSOME=21
GENE_COUNT=234

# Arrays
BASES=(A C G T)
echo "First base: ${BASES[0]}"
echo "All bases: ${BASES[@]}"

# Add to array
BASES+=(N)

# Array length
echo "Number of bases: ${#BASES[@]}"

# String operations
FILE="sample_001.fastq.gz"
NAME="${FILE%.fastq.gz}"     # Remove suffix
echo "Sample name: $NAME"
```

## Conditionals (if/then/else) {.smaller}

``` bash
#!/bin/bash

# Numeric comparisons
COUNT=100
if [ $COUNT -gt 50 ]; then
    echo "High read count"
elif [ $COUNT -gt 10 ]; then
    echo "Medium read count"
else
    echo "Low read count"
fi

# String comparisons
FILETYPE="fasta"
if [ "$FILETYPE" = "fasta" ]; then
    echo "Processing FASTA file"
fi

# File tests
if [ -f "data.txt" ]; then
    echo "File exists"
fi

if [ -d "results" ]; then
    echo "Directory exists"
else
    mkdir results
fi
```

## Loops in Shell Scripts {.smaller}

``` bash
#!/bin/bash

# For loop over list
for BASE in A C G T; do
    echo "Processing base: $BASE"
done

# For loop over files
for FILE in *.fasta; do
    echo "Analyzing $FILE"
    grep -c ">" "$FILE"
done

# For loop with counter
for i in {1..10}; do
    echo "Iteration $i"
done

# While loop
COUNT=1
while [ $COUNT -le 5 ]; do
    echo "Count: $COUNT"
    COUNT=$((COUNT + 1))
done

# Read file line by line
while read LINE; do
    echo "Processing: $LINE"
done < input.txt
```

## Functions in Scripts {.smaller}

``` bash
#!/bin/bash

# Define a function
count_sequences() {
    local FILE=$1  # Local variable
    local COUNT=$(grep -c "^>" "$FILE")
    echo "File $FILE has $COUNT sequences"
    return $COUNT  # Optional return value
}

# Another function with multiple parameters
process_fasta() {
    local INPUT=$1
    local OUTPUT=$2
    
    echo "Processing $INPUT..."
    grep "^>" "$INPUT" > "$OUTPUT"
    count_sequences "$INPUT"
}

# Call functions
count_sequences "proteins.fasta"
process_fasta "input.fasta" "headers.txt"
```

## Error Handling {.smaller}

``` bash
#!/bin/bash

# Exit on error
set -e

# Exit on undefined variable
set -u

# Pipe failure detection
set -o pipefail

# Custom error handling
check_file() {
    if [ ! -f "$1" ]; then
        echo "Error: File $1 not found!" >&2
        exit 1
    fi
}

# Trap errors
trap 'echo "Error on line $LINENO"' ERR

# Try-catch style
if ! grep "pattern" file.txt > /dev/null 2>&1; then
    echo "Pattern not found"
fi
```

## Real Bioinformatics Script Example {.smaller}

``` bash
#!/bin/bash
# Script: fasta_stats.sh
# Purpose: Calculate basic statistics for FASTA files

# Check arguments
if [ $# -ne 1 ]; then
    echo "Usage: $0 sequences.fasta"
    exit 1
fi

INPUT=$1

# Check if file exists
if [ ! -f "$INPUT" ]; then
    echo "Error: File $INPUT not found!"
    exit 1
fi

echo "=== FASTA Statistics for $INPUT ==="

# Count sequences
SEQ_COUNT=$(grep -c "^>" "$INPUT")
echo "Number of sequences: $SEQ_COUNT"

# Calculate total length
TOTAL_LENGTH=$(grep -v "^>" "$INPUT" | tr -d '\n' | wc -c)
echo "Total length: $TOTAL_LENGTH bp"

# Average length
AVG_LENGTH=$((TOTAL_LENGTH / SEQ_COUNT))
echo "Average length: $AVG_LENGTH bp"

# GC content
GC_COUNT=$(grep -v "^>" "$INPUT" | tr -d '\n' | grep -o "[GC]" | wc -l)
GC_PERCENT=$((GC_COUNT * 100 / TOTAL_LENGTH))
echo "GC content: $GC_PERCENT%"
```

## Best Practices for Shell Scripts {.smaller}

1.  **Always include a shebang**: `#!/bin/bash`
2.  **Comment your code**: Explain what and why
3.  **Use meaningful variable names**: `GENE_COUNT` not `GC`
4.  **Check inputs**: Validate files exist and arguments are correct
5.  **Handle errors gracefully**: Use `set -e` and error checking
6.  **Make scripts portable**: Don't hardcode paths
7.  **Use version control**: Track changes with git
8.  **Test incrementally**: Build scripts step by step
9.  **Create help messages**: Document usage
10. **Log important steps**: Keep records of what was done
